#-------------------------------------------------------------------------------
# Get-SAS2IDMDuplicateUSINsAllSchools.ps1
#
# Exception report to identify duplicate USINs across ALL SCHOOLS
#
# Author: Bob Bradley - bob.bradley@unifysolutions.net
#         https://unifysolutions.net/identity/
# Change History
#         12/11/2021 - initial version
#-------------------------------------------------------------------------------
param(
    [string]$sasServer = "OCCCP-DB222",
    [string]$logfile = "D:\Logs\Get-SAS2IDMDuplicateUSINsAllSchools.log",
    [string]$cssfile = "D:\Scripts\Report.css",
    [string]$outputfile = "D:\Logs\SAS2IDMSchools.csv",
    [string]$company = "CSODBB",
    [string]$subject = "SAS Duplicate USINs - All Schools",
    [string]$description = "Exception report to identify duplicate USINs across ALL SCHOOLS",
    [string]$fromaddress = "MIMPROD@dbb.org.au", 
    [string[]]$toaddress = @("csodbbsupport@unifysolutions.net","robert.broadley@dbb.catholic.edu.au"),
    [string]$ccaddress = "bob.bradley@unifysolutions.net",
    [string]$smtpserver = "smtp.dbb.local",
    [switch]$debug,
    [switch]$help
)

# quit on errors
$ErrorActionPreference="Stop"

# show help
if ($help) {
    @"
NAME
    Get-SAS2IDMDuplicateUSINsAllSchools

SYNOPSIS
    Exception report to identify duplicate USINs across ALL SCHOOLS.
    
SYNTAX:
    Get-SAS2IDMDuplicateUSINsAllSchools [[-sasServer] <string>] [[-logfile] <string>] [[-outputfile] <string>] [-help] [-debug]

PARAMETERS:
    -sasServer <string>
        The SAS and SAS2IDM host server. The default value is 'OCCCP-DB222'

    -logfile <string>
        The log file for the last execution record this script. The default value is "D:\Logs\Get-SAS2IDMDuplicateUSINsAllSchools.log".

    -cssfile <string>
        The CSS file required by the script for formatting HTML notifications. The default value is "D:\Scripts\Report.css".

    -outputfile <string>
        The CSV file generated by the script. The default value is "D:\Logs\SAS2IDMDuplicateUSINsAllSchools.csv".

    -company <string>
        The company for whom this report is generated

    -subject <string>
        The report subject

    -description <string>
        The detailed report description

    -fromaddress <string>
        The notification sender email address

    -toaddress []<string>
        The notification recipient email address(es)

    -ccaddress <string>
        The notification CC recipient email address

    -smtpserver <string>
        The SMTP address (if null or empty string, no email will be sent)

    -debug <switch>
        Enable debug messages.

    -help <switch>
        Display this help message and exit.
        
"@
    exit
}

#------------------------------------------------------------------------------------------------------
# Send Email as an attachment
# Based on https://mdaslam.wordpress.com/2015/12/30/powershell-zip-files-and-send-email-with-attachment/
#------------------------------------------------------------------------------------------------------
Function Create-Zip
{
    Param(
        [String]$ZipFileName)
    End
    {
        [string]$tempPath = "$logFilePath\temp"
        New-Item -Force -ItemType directory -Path $tempPath | Out-Null
        Get-ChildItem "$($logFile.Replace($logFileExtension,".csv"))” | ForEach-Object {Copy-Item $_ $tempPath} | Out-Null

        if (Test-Path -path $("$ZipFileName")) 
        { 
            Remove-Item -Force $("$ZipFileName") | Out-Null
        }

        Add-Type -AssemblyName "System.IO.Compression.FileSystem" 
        [System.IO.Compression.ZipFile]::CreateFromDirectory($tempPath, $("$ZipFileName")) | Out-Null

        Remove-Item -Force -Recurse $tempPath | Out-Null
        Return $("$ZipFileName")
    }
}

#------------------------------------------------------------------------------------------------------
# Execute a SQL statement
#------------------------------------------------------------------------------------------------------
function ExecuteSQL 
{
    Param(
        [String]$sql="",
        [String]$connStr="",
        [Int]$cmdTimeout=120,
        [Bool]$dbg=$false)
    End
    {
        if ($sql.Length.Equals(0)) {
            Throw "Mandatory parameter sql not supplied!"
        }
        if ($connStr.Length.Equals(0)) {
            Throw "Mandatory parameter connStr not supplied!"
        }
        $sqlConnection = new-object System.Data.SqlClient.SqlConnection
        $sqlConnection.ConnectionString = $connStr
        if($dbg -eq $true) {Write-Output "Opening SQL Connection => [$($sqlCommand.ConnectionString)] ..." | Out-File -FilePath $logfile -Append}
        $sqlConnection.Open()
        [System.Data.SqlClient.SqlCommand]$sqlCommand = new-object System.Data.SqlClient.SqlCommand
        $sqlCommand.CommandTimeout = $cmdTimeout
        $sqlCommand.Connection = $sqlConnection
        $sqlCommand.CommandText= $sql
        if($dbg -eq $true) {Write-Output "Executing SQL: [$($sqlCommand.CommandText)]" | Out-File -FilePath $logfile -Append}
        [System.Data.DataTable]$dataTable = New-Object System.Data.DataTable
        [System.Data.SqlClient.SqlDataAdapter]$sqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
        $sqlAdapter.SelectCommand = $sqlCommand
        $sqlAdapter.Fill($dataTable)
        $sqlConnection.Close() 
        if($Err){throw $Err}
        return $dataTable #$result
    }
 }

# Initialize hash table for result consolidation
$csvHT = @{}

# initiate logging
if ($debug) {
    Write-Output "$(Get-Date): Generating Report ..."
} else {
    Write-Output "$(Get-Date): Generating Report ..." | Out-File -FilePath $logfile
}

# -- Step #1: Get Duplicate USINs
Write-Output "[$(Get-Date)] Getting Duplicate USINs ..." | Out-File -FilePath $logfile -Append
[string]$db = "SAS2IDM_SAS2IDM_LIVE"
$sql = @"
exec [dbo].[procSAS2IDM_GetDuplicateUSINs_AllSchools]
"@
[string]$conn = "server=$sasServer;database=$db;Integrated Security=SSPI"

$sqlQueryResult = $null
try {
    $sqlQueryResult = @(ExecuteSQL -connStr $conn -sql $sql -cmdTimeout 600)
} catch {
    $err[0]
}

if ($sqlQueryResult) {
    $sqlQueryResult.Where({$_.UniversalIdentificationNumber}) | % {
        [string]$id = "{0}:{1}" -f $_.SchoolNumber, $_.StudentID
        $csvHT.Add($id, @{})
        $csvHT.($id).Add("SchoolCode",$_.SchoolCode)
        $csvHT.($id).Add("SchoolNumber",$_.SchoolNumber)
        $csvHT.($id).Add("StudentID",$_.StudentID)
        $csvHT.($id).Add("Code",$_.Code)
        $csvHT.($id).Add("USIN",$_.UniversalIdentificationNumber)
        $csvHT.($id).Add("PreEnrolment",$_.PreEnrolment)
        $csvHT.($id).Add("FirstName",$_.FirstName)
        $csvHT.($id).Add("MiddleName",$_.MiddleName)
        $csvHT.($id).Add("LastName",$_.LastName)
        $csvHT.($id).Add("Sex",$_.Sex)
        $csvHT.($id).Add("DOB",$_.DOB)
        $csvHT.($id).Add("Year",$_.Year)
        $csvHT.($id).Add("Class",$_.Class)
        $csvHT.($id).Add("Email",$_.Email)
        $csvHT.($id).Add("Archive",$_.Archive)
    }
}

# -- Step #4: Generate CSV Report
# Extend log file name with date/time component
[string]$logFileExtension = [System.IO.Path]::GetExtension($logFile)
[string]$logFileExt = [System.IO.Path]::Combine($logFilePath, $logFile.Replace($logFileExtension, "."+(get-date -Format "yyyy-MM-dd")+$logFileExtension))
[string]$logFilePath = [System.IO.Path]::GetDirectoryName($logfile)
[string]$outputfile = $logFile.Replace($logFileExtension,".csv")
if (Test-Path -path $outputfile) 
{ 
    Remove-Item -Force $outputfile | Out-Null
}

Write-Output "[$(Get-Date)] Writing CSV to $outputfile ..." | Out-File -FilePath $logfile -Append
foreach($csvItem in $csvHT.Keys) {
    if ($csvItem.Length -gt 0) {
        [PSCustomObject]$csvHT.($csvItem) | select USIN,StudentID,Code,SchoolCode,SchoolNumber,Email,LastName,FirstName,MiddleName,DOB,Year,Class,Sex,PreEnrolment,Archive | Export-Csv $outputfile –NoTypeInformation -Append
    }
}

if ($smtpserver.Length -gt 0 -and (Test-Path -path $outputfile)) {
    [string]$archiveFileName = $outputfile -ireplace ".CSV",".ZIP"
    [string]$head = get-content $cssfile
    [string]$spacer = "<table><tr><td class='Spacer'/></tr></table>"
    $description = $description + " ($($csvHT.Keys.Count) records affected)" # Add record count to report description)
    [string]$reportData = [PSCustomObject]@{Company=$company;Date="$(Get-Date)";Server="$($env:COMPUTERNAME)";} | select * | ConvertTo-Html -Fragment -PreContent "<h3>$description</h3>" | Out-String
    [string]$reportBody = Get-Content -Path $outputfile | ConvertFrom-Csv | Sort-object USIN | ConvertTo-Html -Fragment -PreContent $spacer | Out-String
    [string]$body = ConvertTo-Html -Head $head -PostContent $reportBody -PreContent "<h1>$subject</h1>",$reportData
    $attachment = Create-Zip -ZipFileName $archiveFileName
    Send-MailMessage -SmtpServer $smtpserver -Body $body -BodyAsHtml -From $fromaddress -To $toaddress -Cc $ccaddress -Subject $subject -Attachments $attachment
    $attachment = $null
}
        
# finalise logging
if ($debug) {
    Write-Output "$(Get-Date): Report generated OK!"
} else {
    Write-Output "$(Get-Date): Report generated OK!" | Out-File -FilePath $logfile -Append
}
